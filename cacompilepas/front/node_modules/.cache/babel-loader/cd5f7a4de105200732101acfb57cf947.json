{"ast":null,"code":"import React, { createElement } from 'react';\nimport { withRouter, matchPath } from 'react-router';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar DEFAULT_MATCH_OPTIONS = {\n  exact: true\n};\nvar NO_BREADCRUMB = 'NO_BREADCRUMB';\n/**\n * This method was \"borrowed\" from https://stackoverflow.com/a/28339742\n * we used to use the humanize-string package, but it added a lot of bundle\n * size and issues with compilation. This 4-liner seems to cover most cases.\n */\n\nvar humanize = function humanize(str) {\n  return str.replace(/^[\\s_]+|[\\s_]+$/g, '').replace(/[_\\s]+/g, ' ').replace(/^[a-z]/, function (m) {\n    return m.toUpperCase();\n  });\n};\n/**\n * Renders and returns the breadcrumb complete\n * with `match`, `location`, and `key` props.\n */\n\n\nvar render = function render(_ref) {\n  var reactRouterConfigComponent = _ref.component,\n      Breadcrumb = _ref.breadcrumb,\n      match = _ref.match,\n      location = _ref.location,\n      rest = _objectWithoutProperties(_ref, [\"component\", \"breadcrumb\", \"match\", \"location\"]);\n\n  var componentProps = _objectSpread2({\n    match: match,\n    location: location,\n    key: match.url\n  }, rest);\n\n  return _objectSpread2({}, componentProps, {\n    breadcrumb: typeof Breadcrumb === 'string' ? createElement('span', {\n      key: componentProps.key\n    }, Breadcrumb) : React.createElement(Breadcrumb, componentProps)\n  });\n};\n/**\n * Small helper method to get a default breadcrumb if the user hasn't provided one.\n*/\n\n\nvar getDefaultBreadcrumb = function getDefaultBreadcrumb(_ref2) {\n  var pathSection = _ref2.pathSection,\n      currentSection = _ref2.currentSection,\n      location = _ref2.location;\n  var match = matchPath(pathSection, _objectSpread2({}, DEFAULT_MATCH_OPTIONS, {\n    path: pathSection\n  }));\n  return render({\n    breadcrumb: humanize(currentSection),\n    match: match,\n    location: location\n  });\n};\n/**\n * Loops through the route array (if provided) and returns either a\n * user-provided breadcrumb OR a sensible default (if enabled)\n*/\n\n\nvar getBreadcrumbMatch = function getBreadcrumbMatch(_ref3) {\n  var currentSection = _ref3.currentSection,\n      disableDefaults = _ref3.disableDefaults,\n      excludePaths = _ref3.excludePaths,\n      location = _ref3.location,\n      pathSection = _ref3.pathSection,\n      routes = _ref3.routes;\n  var breadcrumb; // Check the optional `exludePaths` option in `options` to see if the\n  // current path should not include a breadcrumb.\n\n  var getIsPathExcluded = function getIsPathExcluded(path) {\n    return matchPath(pathSection, {\n      path: path,\n      exact: true,\n      strict: false\n    });\n  };\n\n  if (excludePaths && excludePaths.some(getIsPathExcluded)) {\n    return NO_BREADCRUMB;\n  } // Loop through the route array and see if the user has provided a custom breadcrumb.\n\n\n  routes.some(function (_ref4) {\n    var userProvidedBreadcrumb = _ref4.breadcrumb,\n        matchOptions = _ref4.matchOptions,\n        path = _ref4.path,\n        rest = _objectWithoutProperties(_ref4, [\"breadcrumb\", \"matchOptions\", \"path\"]);\n\n    if (!path) {\n      throw new Error('withBreadcrumbs: `path` must be provided in every route object');\n    }\n\n    var match = matchPath(pathSection, _objectSpread2({}, matchOptions || DEFAULT_MATCH_OPTIONS, {\n      path: path\n    })); // If user passed breadcrumb: null OR custom match options to suppress a breadcrumb\n    // we need to know NOT to add it to the matches array\n    // see: `if (breadcrumb !== NO_BREADCRUMB)` below.\n\n    if (match && userProvidedBreadcrumb === null || !match && matchOptions) {\n      breadcrumb = NO_BREADCRUMB;\n      return true;\n    }\n\n    if (match) {\n      // This covers the case where a user may be extending their react-router route\n      // config with breadcrumbs, but also does not want default breadcrumbs to be\n      // automatically generated (opt-in).\n      if (!userProvidedBreadcrumb && disableDefaults) {\n        breadcrumb = NO_BREADCRUMB;\n        return true;\n      }\n\n      breadcrumb = render(_objectSpread2({\n        // Although we have a match, the user may be passing their react-router config object\n        // which we support. The route config object may not have a `breadcrumb` param specified.\n        // If this is the case, we should provide a default via `humanize`.\n        breadcrumb: userProvidedBreadcrumb || humanize(currentSection),\n        match: match,\n        location: location\n      }, rest));\n      return true;\n    }\n\n    return false;\n  }); // User provided a breadcrumb prop, or we generated one above.\n\n  if (breadcrumb) {\n    return breadcrumb;\n  } // If there was no breadcrumb provided and user has disableDefaults turned on.\n\n\n  if (disableDefaults) {\n    return NO_BREADCRUMB;\n  } // If the above conditionals don't fire, generate a default breadcrumb based on the path.\n\n\n  return getDefaultBreadcrumb({\n    pathSection: pathSection,\n    // include a \"Home\" breadcrumb by default (can be overrode or disabled in config).\n    currentSection: pathSection === '/' ? 'Home' : currentSection,\n    location: location\n  });\n};\n/**\n * Splits the pathname into sections, then search for matches in the routes\n * a user-provided breadcrumb OR a sensible default.\n*/\n\n\nvar getBreadcrumbs = function getBreadcrumbs(_ref5) {\n  var routes = _ref5.routes,\n      location = _ref5.location,\n      _ref5$options = _ref5.options,\n      options = _ref5$options === void 0 ? {} : _ref5$options;\n  var matches = [];\n  var pathname = location.pathname;\n  pathname.split('?')[0] // Remove trailing slash \"/\" from pathname.\n  .replace(/\\/$/, '') // Split pathname into sections.\n  .split('/') // Reduce over the sections and call `getBreadcrumbMatch()` for each section.\n  .reduce(function (previousSection, currentSection) {\n    // Combine the last route section with the currentSection.\n    // For example, `pathname = /1/2/3` results in match checks for\n    // `/1`, `/1/2`, `/1/2/3`.\n    var pathSection = !currentSection ? '/' : \"\".concat(previousSection, \"/\").concat(currentSection);\n    var breadcrumb = getBreadcrumbMatch(_objectSpread2({\n      currentSection: currentSection,\n      location: location,\n      pathSection: pathSection,\n      routes: routes\n    }, options)); // Add the breadcrumb to the matches array\n    // unless the user has explicitly passed.\n    // { path: x, breadcrumb: null } to disable.\n\n    if (breadcrumb !== NO_BREADCRUMB) {\n      matches.push(breadcrumb);\n    }\n\n    return pathSection === '/' ? '' : pathSection;\n  }, null);\n  return matches;\n};\n/**\n * Takes a route array and recursively flattens it IF there are\n * nested routes in the config.\n*/\n\n\nvar flattenRoutes = function flattenRoutes(routes) {\n  return (routes || []).reduce(function (arr, route) {\n    if (route.routes) {\n      return arr.concat([route].concat(_toConsumableArray(flattenRoutes(route.routes))));\n    }\n\n    return arr.concat(route);\n  }, []);\n};\n\nvar index = function () {\n  var routes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var options = arguments.length > 1 ? arguments[1] : undefined;\n  return function (Component) {\n    return withRouter(function (props) {\n      return createElement(Component, _objectSpread2({}, props, {\n        breadcrumbs: getBreadcrumbs({\n          routes: flattenRoutes(routes),\n          location: props.location,\n          options: options\n        })\n      }));\n    });\n  };\n};\n\nexport default index;\nexport { getBreadcrumbs };","map":null,"metadata":{},"sourceType":"module"}